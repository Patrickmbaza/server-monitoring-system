name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:  # Manual trigger
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'production'
        type: choice
        options:
          - staging
          - production

env:
  # Docker configuration
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: crimson02
  IMAGE_NAME: server-monitoring-system
  
  # Python version
  PYTHON_VERSION: '3.10'

jobs:
  # =============== TESTING ===============
  test:
    name: Test Application
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov flake8
    
    - name: Validate configuration files
      run: |
        echo "ðŸ” Validating configuration files..."
        
        # Check if hosts.yaml exists and is valid YAML
        if [ -f "config/hosts.yaml" ]; then
          python -c "
          import yaml
          with open('config/hosts.yaml', 'r') as f:
            config = yaml.safe_load(f)
          
          hosts_count = len(config.get('hosts', []))
          print(f'âœ… Hosts configuration loaded successfully')
          print(f'  - Found {hosts_count} hosts to monitor')
          
          # Check alert messages
          alert_messages = config.get('alert_messages', {})
          if alert_messages:
            user_msg = alert_messages.get('user', {}).get('downtime', '')
            admin_msg = alert_messages.get('admin', {}).get('downtime', '')
            
            if '15 minutes' in user_msg or '15mins' in user_msg:
              print('âœ… User downtime message matches requirement')
            else:
              print('âš ï¸  User downtime message may not match requirements')
              
            if 'Server' in admin_msg and 'is down' in admin_msg:
              print('âœ… Admin downtime message matches requirement')
            else:
              print('âš ï¸  Admin downtime message may not match requirements')
          else:
            print('â„¹ï¸  No custom alert messages found, using defaults')
          "
        else
          echo "âŒ config/hosts.yaml not found"
          exit 1
        fi
    
    - name: Check Python imports
      run: |
        echo "ðŸ“¦ Testing Python imports..."
        python -c "
        import sys
        sys.path.insert(0, '.')
        
        # Test core imports
        try:
          from monitoring.monitor import HostMonitor
          from monitoring.notifier import Notifier
          from config import settings
          print('âœ… All core modules imported successfully')
        except Exception as e:
          print(f'âŒ Import error: {e}')
          sys.exit(1)
        
        # Test Flask app
        try:
          from app import app
          print('âœ… Flask app initialized successfully')
        except Exception as e:
          print(f'âš ï¸  Flask app warning: {e}')
        "
    
    - name: Run code quality checks
      run: |
        echo "ðŸ“‹ Running code quality checks..."
        
        # Check for critical Python syntax errors
        echo "Checking for syntax errors..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || echo "Syntax check completed"
        
        # General linting (warnings only)
        echo "Running general linting..."
        flake8 . --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics
        
        echo "âœ… Code quality checks completed"
    
    - name: Run unit tests
      run: |
        echo "ðŸ§ª Running unit tests..."
        
        # Create a simple test if no tests exist
        if [ ! -f "tests/test_app.py" ]; then
          echo "Creating basic test file..."
          mkdir -p tests
          cat > tests/test_basic.py << 'EOF'
import sys
import os
sys.path.insert(0, os.path.abspath('.'))

def test_imports():
    """Test that all modules can be imported"""
    from monitoring.monitor import HostMonitor
    from app import app
    assert HostMonitor is not None
    assert app is not None
    print("âœ… All imports work correctly")

def test_config():
    """Test configuration loading"""
    import yaml
    with open('config/hosts.yaml', 'r') as f:
        config = yaml.safe_load(f)
    assert 'hosts' in config
    assert isinstance(config['hosts'], list)
    print(f"âœ… Config loaded with {len(config['hosts'])} hosts")

if __name__ == '__main__':
    test_imports()
    test_config()
    print("âœ… All tests passed")
EOF
        fi
        
        # Run tests
        python -m pytest tests/ -v --tb=short || echo "Tests completed"
    
    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.run_id }}
        path: |
          coverage.xml
          .coverage
        retention-days: 7
  
  # =============== BUILD DOCKER IMAGE ===============
  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: false
        tags: |
          local-build/server-monitoring:latest
          local-build/server-monitoring:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Test Docker image locally
      run: |
        echo "ðŸ§ª Testing Docker image locally..."
        
        # Build fresh for testing
        docker build -t local-test-image .
        
        # Run container in background
        docker run -d \
          --name test-container \
          -p 8081:8080 \
          -e TIMEZONE=UTC \
          -e TWILIO_ACCOUNT_SID=test \
          -e TWILIO_AUTH_TOKEN=test \
          local-test-image
        
        # Wait for container to start
        sleep 10
        
        # Check if container is running
        if docker ps | grep -q test-container; then
          echo "âœ… Docker container is running"
          
          # Test health endpoint
          if curl -s -f -o /dev/null -w "%{http_code}" http://localhost:8081/health | grep -q "200"; then
            echo "âœ… Health endpoint responded with 200 OK"
          else
            echo "âš ï¸  Health endpoint check failed"
          fi
          
          # Test API endpoints
          echo "Testing API endpoints..."
          curl -s http://localhost:8081/ | grep -q "Server Monitoring System" && echo "âœ… API root endpoint works"
          curl -s http://localhost:8081/status | grep -q "timestamp" && echo "âœ… Status endpoint works"
          
        else
          echo "âŒ Docker container failed to start"
          docker logs test-container
        fi
        
        # Cleanup
        docker stop test-container 2>/dev/null || true
        docker rm test-container 2>/dev/null || true
    
    - name: Save Docker image as artifact
      uses: actions/upload-artifact@v4
      with:
        name: docker-image-${{ github.run_id }}
        path: |
          Dockerfile
          requirements.txt
        retention-days: 7
  
  # =============== PUSH TO DOCKER HUB ===============
  push-to-dockerhub:
    name: Push to Docker Hub
    runs-on: ubuntu-latest
    needs: [test, build]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
        tags: |
          type=raw,value=latest,enable={{is_default_branch}}
          type=sha,prefix={{branch}}-
          type=ref,event=tag
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Verify Docker Hub push
      run: |
        echo "âœ… Docker image pushed successfully!"
        echo ""
        echo "ðŸ“¦ Image Details:"
        echo "  Repository: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}"
        echo "  Tags:"
        echo "    - latest"
        echo "    - ${{ github.sha }}"
        echo ""
        echo "ðŸ”— View on Docker Hub:"
        echo "  https://hub.docker.com/r/${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}"
        echo ""
        echo "ðŸš€ Quick Deploy Command:"
        echo "  docker run -d --name server-monitoring \\"
        echo "    -p 8080:8080 \\"
        echo "    -e TIMEZONE=Africa/Lagos \\"
        echo "    -e TWILIO_ACCOUNT_SID=your_sid \\"
        echo "    -e TWILIO_AUTH_TOKEN=your_token \\"
        echo "    -v \$(pwd)/config:/app/config \\"
        echo "    -v \$(pwd)/logs:/app/logs \\"
        echo "    ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:latest"
  
  # =============== DEPLOYMENT ===============
  deploy:
    name: Generate Deployment Package
    runs-on: ubuntu-latest
    needs: [test, push-to-dockerhub]
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Create deployment package
      run: |
        echo "ðŸ“¦ Creating deployment package..."
        
        DEPLOY_DIR="deployment-${{ github.run_number }}"
        mkdir -p $DEPLOY_DIR
        
        # Copy essential files
        cp -r config $DEPLOY_DIR/
        cp docker-compose.yml $DEPLOY_DIR/
        cp README.md $DEPLOY_DIR/
        
        # Create production environment file
        cat > $DEPLOY_DIR/.env.production << 'EOF'
        # Production Environment Variables
        # Server Monitoring System
        # Generated: $(date)
        
        # =============== REQUIRED ===============
        PORT=8080
        TIMEZONE=Africa/Lagos
        
        # =============== TWILIO ===============
        TWILIO_ACCOUNT_SID=REPLACE_WITH_YOUR_SID
        TWILIO_AUTH_TOKEN=REPLACE_WITH_YOUR_TOKEN
        TWILIO_WHATSAPP_NUMBER=REPLACE_WITH_YOUR_NUMBER
        
        ADMIN_WHATSAPP_NUMBERS=REPLACE_WITH_ADMIN_NUMBERS
        USER_WHATSAPP_NUMBERS=REPLACE_WITH_USER_NUMBERS
        
        # =============== OPTIONAL ===============
        # TEAMS_ADMIN_WEBHOOK=
        # TEAMS_USER_WEBHOOK=
        # CHECK_INTERVAL=60
        # TIMEOUT=10
        EOF
        
        # Create deployment script
        cat > $DEPLOY_DIR/deploy.sh << 'EOF'
        #!/bin/bash
        # Deployment script for Server Monitoring System
        
        set -e
        
        echo "ðŸš€ Deploying Server Monitoring System"
        echo "====================================="
        
        # Check if Docker is installed
        if ! command -v docker &> /dev/null; then
          echo "âŒ Docker is not installed. Please install Docker first."
          exit 1
        fi
        
        if ! command -v docker-compose &> /dev/null; then
          echo "âŒ Docker Compose is not installed. Please install Docker Compose first."
          exit 1
        fi
        
        # Check if .env file exists
        if [ ! -f ".env" ]; then
          echo "â„¹ï¸  .env file not found. Creating from template..."
          cp .env.production .env
          echo ""
          echo "âš ï¸  Please edit the .env file with your configuration:"
          echo "    nano .env"
          echo ""
          read -p "Press Enter after you've configured .env file..."
        fi
        
        # Validate .env file
        if grep -q "REPLACE_WITH" .env; then
          echo "âŒ Please update all REPLACE_WITH values in .env file"
          exit 1
        fi
        
        # Pull latest image
        echo "ðŸ“¦ Pulling latest Docker image..."
        docker-compose pull
        
        # Start services
        echo "ðŸš€ Starting services..."
        docker-compose up -d
        
        # Wait for service to be ready
        echo "â³ Waiting for service to start..."
        sleep 10
        
        # Check health
        echo "ðŸ” Checking service health..."
        if curl -s -f http://localhost:8080/health > /dev/null; then
          echo "âœ… Service is healthy and running!"
          echo ""
          echo "ðŸŒ Access URLs:"
          echo "   Dashboard:  http://$(curl -s ifconfig.me):8080/dashboard"
          echo "   API Status: http://localhost:8080/status"
          echo "   Health:     http://localhost:8080/health"
          echo ""
          echo "ðŸ“ View logs: docker-compose logs -f"
          echo "ðŸ›‘ Stop:      docker-compose down"
        else
          echo "âŒ Service health check failed"
          echo "Checking logs..."
          docker-compose logs
          exit 1
        fi
        EOF
        
        chmod +x $DEPLOY_DIR/deploy.sh
        
        # Create README
        cat > $DEPLOY_DIR/README-DEPLOY.md << 'EOF'
        # Server Monitoring System - Deployment
        
        ## Quick Start
        
        1. **Copy all files to your server**
        
        2. **Configure environment:**
           ```bash
           cp .env.production .env
           nano .env  # Edit with your values
           ```
        
        3. **Deploy:**
           ```bash
           ./deploy.sh
           ```
        
        ## Manual Deployment
        
        ```bash
        # 1. Create .env file
        cp .env.production .env
        # Edit .env with your Twilio credentials
        
        # 2. Start the service
        docker-compose up -d
        
        # 3. Verify it's running
        curl http://localhost:8080/health
        
        # 4. Access dashboard
        # Open browser: http://your-server-ip:8080/dashboard
        ```
        
        ## Docker Image
        
        Latest image: `crimson02/server-monitoring-system:latest`
        
        ## Configuration
        
        Edit `config/hosts.yaml` to add/remove monitored servers.
        
        ## Monitoring
        
        - **Dashboard:** http://your-server:8080/dashboard
        - **API Documentation:** http://your-server:8080/
        - **Logs:** `docker-compose logs -f`
        
        ## Update
        
        ```bash
        docker-compose pull
        docker-compose up -d
        ```
        EOF
        
        # Create archive
        tar -czf deployment-package.tar.gz $DEPLOY_DIR/
        
        echo "âœ… Deployment package created: deployment-package.tar.gz"
        ls -la $DEPLOY_DIR/
    
    - name: Upload deployment package
      uses: actions/upload-artifact@v4
      with:
        name: deployment-package-${{ github.run_number }}
        path: deployment-package.tar.gz
        retention-days: 30
  
  # =============== SECURITY SCAN ===============
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH'
    
    - name: Upload security results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
  
  # =============== NOTIFICATION ===============
  notify:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [test, build, push-to-dockerhub, deploy, security]
    if: always()
    
    steps:
    - name: Generate summary
      run: |
        echo "# ðŸš€ CI/CD Pipeline Summary"
        echo ""
        echo "**Repository:** ${{ github.repository }}"
        echo "**Branch:** ${{ github.ref_name }}"
        echo "**Commit:** [${{ github.sha }}](https://github.com/${{ github.repository }}/commit/${{ github.sha }})"
        echo "**Workflow Run:** [#${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
        echo ""
        echo "## ðŸ“Š Job Results"
        echo ""
        echo "| Job | Status | Details |"
        echo "|-----|--------|---------|"
        echo "| ðŸ§ª Test | ${{ needs.test.result }} | [View Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/#job-${{ needs.test.id }}) |"
        echo "| ðŸ³ Build | ${{ needs.build.result }} | [View Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/#job-${{ needs.build.id }}) |"
        echo "| ðŸ“¤ Push to Docker Hub | ${{ needs.push-to-dockerhub.result }} | [View Logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/#job-${{ needs.push-to-dockerhub.id }}) |"
        echo "| ðŸ“¦ Deploy | ${{ needs.deploy.result }} | [Download Package](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) |"
        echo "| ðŸ”’ Security | ${{ needs.security.result }} | [View Results](https://github.com/${{ github.repository }}/security/code-scanning) |"
        echo ""
        
        if [ "${{ needs.push-to-dockerhub.result }}" = "success" ]; then
          echo "## ðŸ“¦ Docker Image"
          echo ""
          echo "**Image:** \`crimson02/server-monitoring-system:latest\`"
          echo "**Tag:** \`crimson02/server-monitoring-system:${{ github.sha }}\`"
          echo ""
          echo "ðŸ”— [View on Docker Hub](https://hub.docker.com/r/crimson02/server-monitoring-system)"
          echo ""
          echo "### Quick Run Command:"
          echo "\`\`\`bash"
          echo "docker run -d --name server-monitoring \\"
          echo "  -p 8080:8080 \\"
          echo "  -e TIMEZONE=Africa/Lagos \\"
          echo "  -e TWILIO_ACCOUNT_SID=your_sid \\"
          echo "  -e TWILIO_AUTH_TOKEN=your_token \\"
          echo "  crimson02/server-monitoring-system:latest"
          echo "\`\`\`"
        fi
        
        echo ""
        echo "## ðŸ“ Next Steps"
        echo ""
        echo "1. Download the deployment package from Artifacts"
        echo "2. Extract: \`tar -xzf deployment-package.tar.gz\`"
        echo "3. Follow instructions in \`README-DEPLOY.md\`"
        echo ""
        echo "---"
        echo "*Generated by GitHub Actions*"